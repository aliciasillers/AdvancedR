---
title: "chapter 8"
output: 
  html_document:
    keep_md: true
date: "2022-10-31"
---




```r
library(rlang)
```


# Quiz

1. What are the three most important types of condition?    
My answer: Errors, warnings, and maybe calling handlers     
Textbook answer: error, warning, and message    

2. What function do you use to ignore errors in block of code?    
My answer: I don't know   
Textbook answer: You could use try() or tryCatch().   

3. What’s the main difference between tryCatch() and withCallingHandlers()?
My answer: I don't know   
Textbook answer: tryCatch() creates exiting handlers which will terminate the execution of wrapped code; withCallingHandlers() creates calling handlers which don’t affect the execution of wrapped code.   

4. Why might you want to create a custom error object?
My answer: Maybe in order to have a record of the errors in case you need to fix them at a later time than immediately after running the code.
Textbook answer: Because you can then capture specific types of error with tryCatch(), rather than relying on the comparison of error strings, which is risky, especially when messages are translated.

# 8.2.4 Exercises

1. Write a wrapper around file.remove() that throws an error if the file to be deleted does not exist.    
Answer:

```r
file.remove2 <- function(x) {
  if (exists(x)) {
    file.remove(x)
  }
  else {
    stop("File does not exist.")
  }
}
```

2. What does the appendLF argument to message() do? How is it related to cat()?   
Answer: When appendLF = TRUE, the message is printed on its own line, whereas when appendLF = FALSE, the message is printed on the same line as other messages. cat() prints with concatenation, merging multiple strings into one. This is related because it is what happens when using message() with appendLF = FALSE. 

# 8.4.5 Exercises

1. What extra information does the condition generated by abort() contain compared to the condition generated by stop() i.e. what’s the difference between these two objects? Read the help for ?abort to learn more.
Answer: stop() includes the call by default, while abort() does not. abort() can also include additional metadata. One more difference is that stop() generates errors of the base class while abort generates errors of the rlang class.

2. Predict the results of evaluating the following code

```r
show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
      NULL
    }
  )
}

show_condition(stop("!"))
```

```
## [1] "error"
```

```r
show_condition(10)
```

```
## NULL
```

```r
show_condition(warning("?!"))
```

```
## [1] "warning"
```

```r
show_condition({
  10
  message("?")
  warning("?!")
})
```

```
## [1] "message"
```
Answer: The first evaluation will print "error," the second will print 10 and the NULL, the third will print "warning" and the fourth will print 10, "message," and "warning"


3. Explain the results of running this code:

```r
withCallingHandlers(
  message = function(cnd) message("b"),
  withCallingHandlers(
    message = function(cnd) message("a"),
    message("c")
  )
)
```

```
## b
```

```
## a
```

```
## b
```

```
## c
```

```r
#> b
#> a
#> b
#> c
```
Answer: The first function prints "b" and then goes to the nested function. The first message of the nested function prints "a" and then calls the other messages starting with "b" and then going to "c"

4. Read the source code for catch_cnd() and explain how it works.   
Answer: It is a wrapper that captures the condition signaled while evaluating its argument

5. How could you rewrite show_condition() to use a single handler?    
Answer: 

```r
show_condition <- function(code) {
  handler <- function(x = catch_cnd(code)) {
  tryCatch(
    x[2]
  )
  }
}

show_condition(stop("!"))
show_condition(10)
show_condition(warning("?!"))
```

# 8.5.4 Exercises

1. Inside a package, it’s occasionally useful to check that a package is installed before using it. Write a function that checks if a package is installed (with requireNamespace("pkg", quietly = FALSE)) and if not, throws a custom condition that includes the package name in the metadata.   
Answer:

```r
abort_no_package <- function(arg) {
  msg <- glue::glue("package `{arg}` is not installed")
  
  
  abort("error_no_package", 
    message = msg, 
    arg = arg
  )
}

my_requirenamespace <- function(x, quietly = FALSE) {
  if (!exists(x)) {
    abort_no_package(x)
  }


requireNamespace(x, quietly = FALSE)
}

#my_requirenamespace("pkgs")
#>error in 'abort_no_package()': package 'pkgs' is not installed
```

2. Inside a package you often need to stop with an error when something is not right. Other packages that depend on your package might be tempted to check these errors in their unit tests. How could you help these packages to avoid relying on the error message which is part of the user interface rather than the API and might change without notice?   
Answer: You could create custom errors that have additional metadata so that packages could check for the metadata instead of the message. 

#8.6.6 Exercises

1. Create suppressConditions() that works like suppressMessages() and suppressWarnings() but suppresses everything. Think carefully about how you should handle errors.    
Answer:

```r
suppressConditions <- function(expr){
  tryCatch(
    error = function(cnd) try(expr, silent = TRUE),
    withCallingHandlers(
    warning = function(cnd) 
    if (inherits(cnd, "warning"))
      tryInvokeRestart("muffleWarning"),
    message = function(cnd)
    if (inherits(cnd, "message"))
      tryInvokeRestart("muffleMessage"),
    expr
  )
  )
}

suppressConditions(message("a"))
suppressConditions(warning("b"))
suppressConditions(stop("c"))
```

```
## Warning in doTryCatch(return(expr), name, parentenv, handler): restarting
## interrupted promise evaluation
```

2. Compare the following two implementations of message2error(). What is the main advantage of withCallingHandlers() in this scenario? (Hint: look carefully at the traceback.)

```r
message2error <- function(code) {
  withCallingHandlers(code, message = function(e) stop(e))
}

#message2error()

message2error <- function(code) {
  tryCatch(code, message = function(e) stop(e))
}

#message2error()
```
Answer: The version using withCallingHandlers printed the exact line of code where the error occurred in the traceback, whereas the version using TryCatch showed that is was an error in a TryCatch function but did not print the code as it was written, which could be confusing if TryCatch was used multiple times.   

3. How would you modify the catch_cnds() definition if you wanted to recreate the original intermingling of warnings and messages?   
Answer: 

```r
catch_cnds <- function(expr) {
  conds <- list()
  add_cond <- function(cnd) {
    conds <<- append(conds, list(cnd))
    cnd_muffle(cnd)
  }
  
  withCallingHandlers(
    condition = add_cond,
    expr
  )
  
  conds
}

catch_cnds({
  inform("a")
  warn("b")
  inform("c")
})
```

```
## [[1]]
## <message/rlang_message>
## Message:
## a
## 
## [[2]]
## <warning/rlang_warning>
## Warning:
## b
## 
## [[3]]
## <message/rlang_message>
## Message:
## c
```

4. Why is catching interrupts dangerous? Run this code to find out.

```r
bottles_of_beer <- function(i = 99) {
  message(
    "There are ", i, " bottles of beer on the wall, ", 
    i, " bottles of beer."
  )
  while(i > 0) {
    tryCatch(
      Sys.sleep(1),
      interrupt = function(err) {
        i <<- i - 1
        if (i > 0) {
          message(
            "Take one down, pass it around, ", i, 
            " bottle", if (i > 1) "s", " of beer on the wall."
          )
        }
      }
    )
  }
  message(
    "No more bottles of beer on the wall, ", 
    "no more bottles of beer."
  )
}
```
Answer: 

```r
#bottles_of_beer()
```
I think the danger of catching interrupts is that the code isn't able to finish running
