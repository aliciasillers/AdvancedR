---
title: "chapter 8"
output: 
  html_document:
    keep_md: true
date: "2022-10-31"
---




```r
library(rlang)
```


# Quiz

1. What are the three most important types of condition?    
My answer: Errors, warnings, and maybe calling handlers     
Textbook answer: error, warning, and message    

2. What function do you use to ignore errors in block of code?    
My answer: I don't know   
Textbook answer: You could use try() or tryCatch().   

3. What’s the main difference between tryCatch() and withCallingHandlers()?
My answer: I don't know   
Textbook answer: tryCatch() creates exiting handlers which will terminate the execution of wrapped code; withCallingHandlers() creates calling handlers which don’t affect the execution of wrapped code.   

4. Why might you want to create a custom error object?
My answer: Maybe in order to have a record of the errors in case you need to fix them at a later time than immediately after running the code.
Textbook answer: Because you can then capture specific types of error with tryCatch(), rather than relying on the comparison of error strings, which is risky, especially when messages are translated.

# 8.2.4 Exercises

1. Write a wrapper around file.remove() that throws an error if the file to be deleted does not exist.    
Answer:

```r
file.remove2 <- function(x) {
  if (exists(x)) {
    file.remove(x)
  }
  else {
    stop("File does not exist.")
  }
}
```

2. What does the appendLF argument to message() do? How is it related to cat()?   
Answer: When appendLF = TRUE, the message is printed on its own line, whereas when appendLF = FALSE, the message is printed on the same line as other messages. cat() prints with concatenation, merging multiple strings into one. This is related because it is what happens when using message() with appendLF = FALSE. 

# 8.4.5 Exercises

1. What extra information does the condition generated by abort() contain compared to the condition generated by stop() i.e. what’s the difference between these two objects? Read the help for ?abort to learn more.
Answer: stop() includes the call by default, while abort() does not. abort() can also include additional metadata. One more difference is that stop() generates errors of the base class while abort generates errors of the rlang class.

2. Predict the results of evaluating the following code

```r
show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
      NULL
    }
  )
}

show_condition(stop("!"))
```

```
## [1] "error"
```

```r
show_condition(10)
```

```
## NULL
```

```r
show_condition(warning("?!"))
```

```
## [1] "warning"
```

```r
show_condition({
  10
  message("?")
  warning("?!")
})
```

```
## [1] "message"
```
Answer: The first evaluation will print "error," the second will print 10 and the NULL, the third will print "warning" and the fourth will print 10, "message," and "warning"


3. Explain the results of running this code:

```r
withCallingHandlers(
  message = function(cnd) message("b"),
  withCallingHandlers(
    message = function(cnd) message("a"),
    message("c")
  )
)
```

```
## b
```

```
## a
```

```
## b
```

```
## c
```

```r
#> b
#> a
#> b
#> c
```
Answer: After one calling handler in a withCallingHandlers function, the code resets, so it prints the "b" then the first message of the nested function, then resets and prints "b" and the second message of the nested function.

4. Read the source code for catch_cnd() and explain how it works.   
Answer: It is a wrapper that captures the condition signalled while evaluating its argument

5. How could you rewrite show_condition() to use a single handler?    
Answer: 

```r
show_condition <- function(code) {
  handler <- function(x = catch_cnd(code)) {
  tryCatch(
    x = function(cnd) "x",
    {
      code
      NULL
    }
  )
  }
}
```

